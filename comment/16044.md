---
node: Designing Tools for Learners (Not Users)
author: warren
created_at: 2017-01-06 21:32:17 +0000
timestamp: 1483738337
nid: 13823
cid: 16044
uid: 1
---



[warren](../profile/warren) replying to: [Designing Tools for Learners (Not Users)](../notes/kanarinka/12-29-2016/designing-tools-for-learners-not-users)

----
I've been thinking more about this and recalled Sara Hendren's great piece [All Technology is Assistive](https://backchannel.com/all-technology-is-assistive-ac9f7183c8cd), which I love. 

I started thinking that there's something related to what you're describing as well -- which I have yet to articulate fully in my hear. Perhaps it's that if we thought of all technology addressing newcomers, or learners, that would be a productive framework. I mean, so much of expertise is non-linear -- although even Harry Collins talks about experts and non-experts in the sense of a spectrum, within a group of experts, there are many different understandings of the same body of information. Both experts and learners are adapting to, and learning from, one anothers' viewpoints. 

I'm thinking that if we design as if all technology is for newcomers, it's not just the newcomers who gain. In some ways, our [#first-timers-only](/tag/first-timers-only) and other [#software-outreach](/tag/software-outreach) strategies are bearing this out -- we've been observing that the specific practices that go into [making a first-timers-only issue](https://publiclab.org/notes/warren/10-31-2016/create-a-welcoming-first-timers-only-issue-to-invite-new-software-contributors) are also beneficial for those who know a great deal about the codebase, or about programming. They lead to good practices in terms of code modularization, of clean and legible interfaces between different functions, and to breaking complex problems up into self-contained, testable, re-usable solutions. 

I don't know if this is generalizable, but I'm tempted to look closer. The same aspects that make our code easier for newcomers to contribute to are powerful ones for coders of all levels, and in many ways it's the "experts" who often think they don't have to follow such strict conventions because they're "good enough" to just hold it all in their heads at once -- which can lead to buggy, unmaintainable and unreadable code. 

I think I have to stew on this a bit more, but I guess one thing that strikes me is that I used to think that making engaging onboarding pathways was something only bigger, high-capacity projects could take on, and that it'd be faster to "just get things done" before inviting others in. After the past six months of our new software outreach initiatives, I think the opposite is true -- the only way to build enough capacity to get things done quickly is to treat every problem as one you can help someone else tackle. 

Whoa, that was a lot! I'm also curious to hear from [@cindy_excites](/profile/cindy_excites) or [@hagitkeysar](/profile/hagitkeysar) on this topic, they having spent a great deal of time thinking through some of these issues. 